const LIVE_API_URL = "https://signalgeniusai-production.up.railway.app/signal/latest";
const SB_URL = "https://wttsaprezgvircanthbk.supabase.co/rest/v1/fx_signals";
const SB_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind0dHNhcHJlemd2aXJjYW50aGJrIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2ODM2ODA3MCwiZXhwIjoyMDgzOTQ0MDcwfQ.QGewz8bDfBC6vJce6g4-sHA164bL1y0u71d6HH7PYVk";

let activeTab = 'active';
let historyOffset = 0;
const PAGE_SIZE = 10;

// Live Price Feed (Binance WebSocket)
let pHistory = [];
let livePrice = null;
let prevPrice = 0;

// --- UTILS ---

function calculateRR(entry, sl, tp, direction) {
    if (!entry || !sl || !tp) return "n/a";
    try {
        const r = Math.abs(entry - sl);
        const rwd = Math.abs(tp - entry);
        if (r === 0) return "1.00";
        return (rwd / r).toFixed(2);
    } catch (e) { return "n/a"; }
}

function getTradingViewLink(symbol, timeframe) {
    if (!symbol) return "#";
    const cleanSymbol = symbol.replace('/', '');
    const tvSymbol = cleanSymbol.includes(':') ? cleanSymbol : `FX:${cleanSymbol}`;
    const tf = timeframe ? timeframe.replace('M', '') : '15';
    return `https://www.tradingview.com/chart/?symbol=${tvSymbol}&interval=${tf}`;
}

async function copySignalToClipboard(sig) {
    if (!sig) return;
    const dt = new Date(sig.generated_at || sig.timestamp || new Date());
    const timeStr = dt.toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
    const entry = sig.entry || sig.entry_price || sig.entry_low || 0;
    const text = `${sig.asset} ${sig.direction}\nEntry: ${entry}\nSL: ${sig.sl || 0}\nTP: ${sig.tp || 0}\nTime: ${timeStr}\nGenerated by Signal Genius AI`;

    try {
        await navigator.clipboard.writeText(text);
        const btn = document.getElementById('copy-signal-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '‚úÖ Copied!';
        setTimeout(() => btn.innerHTML = originalText, 2000);
    } catch (err) {
        console.error('Failed to copy: ', err);
    }
}

// --- TRADINGVIEW MODAL LOGIC ---

window.openTVPreview = (symbol, timeframe, entry, sl, tp, generated_at) => {
    const modal = document.getElementById('tv-modal');
    const iframe = document.getElementById('tv-iframe');

    // Format Display
    document.getElementById('modal-title').innerText = `${symbol} ¬∑ ${timeframe} ¬∑ TradingView Preview`;
    document.getElementById('modal-entry').innerText = parseFloat(entry).toFixed(5);
    document.getElementById('modal-sl').innerText = parseFloat(sl).toFixed(5);
    document.getElementById('modal-tp').innerText = parseFloat(tp).toFixed(5);

    const dt = new Date(generated_at);
    document.getElementById('modal-utc').innerText = dt.toISOString().replace('T', ' ').slice(0, 16);

    document.getElementById('modal-external-link').href = getTradingViewLink(symbol, timeframe);

    // Set Iframe URL (Using Widget Embed for best performance)
    const cleanSymbol = symbol.replace('/', '');
    const tvSymbol = cleanSymbol.includes(':') ? cleanSymbol : `FX:${cleanSymbol}`;
    const tf = timeframe ? timeframe.replace('M', '') : '15';

    iframe.src = `https://s.tradingview.com/widgetembed/?symbol=${tvSymbol}&interval=${tf}&theme=dark`;

    modal.classList.add('active');
    document.body.style.overflow = 'hidden'; // Prevent scroll
};

window.closeTVModal = () => {
    const modal = document.getElementById('tv-modal');
    const iframe = document.getElementById('tv-iframe');
    iframe.src = ""; // Stop iframe loading
    modal.classList.remove('active');
    document.body.style.overflow = 'auto';
};

// Close modal on background click
document.addEventListener('click', (e) => {
    const modal = document.getElementById('tv-modal');
    if (e.target === modal) closeTVModal();
});

// Tab Switching Logic
window.switchTab = (tab) => {
    activeTab = tab;

    // Update Button UI
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.innerText.toLowerCase().includes(tab)) btn.classList.add('active');
    });

    // Toggle Content
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.getElementById(`${tab}-tab`).classList.add('active');

    if (tab === 'history') loadHistory(false);
};

// --- ACTIVE TAB LOGIC ---

function isMarketOpen() {
    const now = new Date();
    const day = now.getUTCDay(); // 0 is Sunday, 6 is Saturday
    const hour = now.getUTCHours();
    // Forex: Open Sun 22:00 UTC to Fri 22:00 UTC
    if (day === 6) return false;
    if (day === 5 && hour >= 22) return false;
    if (day === 0 && hour < 22) return false;
    return true;
}

async function fetchLatestSignal() {
    const recordEl = document.getElementById('signal-record');
    const closedEl = document.getElementById('market-closed');
    const scanningEl = document.getElementById('no-signal-view');
    const scanningTextEl = document.getElementById('scanning-text');

    if (!isMarketOpen()) {
        if (recordEl) {
            recordEl.style.display = 'none';
            const subtitle = recordEl.querySelector('#record-subtitle');
            if (subtitle) subtitle.textContent = "Market Closed ‚Äì No live execution";
        }
        if (scanningEl) scanningEl.style.display = 'none';
        if (closedEl) closedEl.style.display = 'flex';
        return;
    }

    try {
        // Fetch directly from Supabase - latest active signal
        const url = `${SB_URL}?select=*&telegram_message_id=not.is.null&order=generated_at.desc&limit=1`;

        const response = await fetch(url, {
            headers: {
                "apikey": SB_KEY,
                "Authorization": `Bearer ${SB_KEY}`
            }
        });

        if (!response.ok) throw new Error("Supabase Error");
        const data = await response.json();

        if (!data || data.length === 0) {
            // Market open but no signal data at all
            if (recordEl) recordEl.style.display = 'none';
            if (closedEl) closedEl.style.display = 'none';
            if (scanningEl) {
                scanningEl.style.display = 'flex';
                if (scanningTextEl) scanningTextEl.textContent = "Scanning Market...";
            }
            return;
        }

        // We have a signal, display it
        displayActiveSignal(data[0]);
    } catch (error) {
        console.error("Fetch failed:", error);
        if (scanningEl) {
            scanningEl.style.display = 'flex';
            if (scanningTextEl) scanningTextEl.textContent = "Connection Issue...";
        }
    }
}

function displayActiveSignal(record) {
    const recordEl = document.getElementById('signal-record');
    if (!recordEl) return;

    recordEl.style.display = 'flex';
    document.getElementById('market-closed').style.display = 'none';
    document.getElementById('no-signal-view').style.display = 'none';

    // Update Subtitle based on market
    const subtitle = recordEl.querySelector('#record-subtitle');
    if (subtitle) {
        subtitle.textContent = "Pre-Market Structure Analysis";
    }

    // Basic Info
    const asset = record.asset || 'EURUSD';
    const tf = record.timeframe || 'M15';
    const direction = record.direction || 'BUY';
    const entry = record.entry_price || record.entry_low || 0;
    const tp = record.tp || 0;
    const sl = record.sl || 0;
    const confidence = record.confidence || record.ai_confidence || 85;

    document.getElementById('record-asset').textContent = asset;
    document.getElementById('record-tf').textContent = tf;

    // Direction with Emoji
    const dirText = direction === 'BUY' ? 'üü¢ BUY' : 'üî¥ SELL';
    document.getElementById('record-direction-text').textContent = dirText;
    document.getElementById('record-direction-text').style.color = direction === 'BUY' ? 'var(--trade-up)' : 'var(--trade-down)';

    // Prices
    document.getElementById('record-entry').textContent = parseFloat(entry).toFixed(5);
    document.getElementById('record-tp').textContent = parseFloat(tp).toFixed(5);
    document.getElementById('record-sl').textContent = parseFloat(sl).toFixed(5);

    // AI & Constraints
    const displayConfidence = confidence <= 1 ? Math.round(confidence * 100) : Math.round(confidence);
    document.getElementById('record-confidence').textContent = `${displayConfidence}%`;

    // Duration Logic
    const entryLimit = record.activation_limit_mins || 15;
    const maxTrade = record.max_monitoring_mins || 35;
    document.getElementById('record-entry-duration').textContent = `${entryLimit}m`;
    document.getElementById('record-max-duration').textContent = `${maxTrade}m`;
    document.getElementById('record-warning-time').textContent = maxTrade;

    // Valid Until
    const genDate = new Date(record.generated_at);
    if (!isNaN(genDate.getTime())) {
        const validDate = new Date(genDate.getTime() + entryLimit * 60000);
        const validStr = validDate.toLocaleTimeString('en-GB', { hour12: false, timeZone: 'UTC' }).slice(0, 5);
        document.getElementById('record-valid-until').textContent = `${validStr} UTC`;
    }

    // Status Badge Logic
    const state = record.state || 'WAITING_FOR_ENTRY';
    const statusBadge = document.getElementById('record-status-badge');

    if (state === 'WAITING_FOR_ENTRY') {
        statusBadge.textContent = 'PENDING ENTRY';
        statusBadge.style.color = 'var(--quantix-accent)';
    } else if (state === 'ENTRY_HIT') {
        statusBadge.textContent = 'LIVE TRADE';
        statusBadge.style.color = 'var(--trade-up)';
    } else if (state === 'TP_HIT') {
        statusBadge.textContent = 'TP REACHED';
        statusBadge.style.color = 'var(--trade-up)';
    } else if (state === 'SL_HIT') {
        statusBadge.textContent = 'SL REACHED';
        statusBadge.style.color = 'var(--trade-down)';
    } else if (state === 'CANCELLED' || state === 'EXPIRED') {
        statusBadge.textContent = 'EXPIRED';
        statusBadge.style.color = '#64748b';
    } else {
        statusBadge.textContent = state.replace(/_/g, ' ');
        statusBadge.style.color = 'var(--text-secondary)';
    }
}

// --- HISTORY TAB LOGIC ---

async function loadHistory(append = false) {
    const tbody = document.getElementById('history-body');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const pageInfo = document.getElementById('page-info');

    // Get outcome from active tab
    const activeOutcomeTab = document.querySelector('.outcome-tab.active');
    const outcome = activeOutcomeTab ? activeOutcomeTab.getAttribute('data-value') : 'ALL';

    if (!append) {
        historyOffset = 0;
    }

    tbody.innerHTML = '<tr><td colspan="9" style="text-align:center">‚è≥ Fetching History...</td></tr>';
    if (prevBtn) prevBtn.disabled = true;
    if (nextBtn) nextBtn.disabled = true;

    try {
        const dateRange = document.getElementById('filter-date').value;

        let url = `${SB_URL}?select=*&limit=${PAGE_SIZE}&offset=${historyOffset}`;
        url += `&order=generated_at.desc`; // Default newest first
        url += `&telegram_message_id=not.is.null`; // SINGLE SOURCE OF TRUTH: Only telegram-released signals

        // Date Range Filter
        if (dateRange !== "0") {
            const days = parseInt(dateRange);
            const d = new Date();
            d.setDate(d.getDate() - days);
            url += `&generated_at=gte.${d.toISOString()}`;
        }

        // Outcome filter
        if (outcome !== 'ALL') {
            const stateMap = {
                'PROFIT': 'TP_HIT',
                'LOSS': 'SL_HIT',
                'CANCELLED': 'CANCELLED',
                'PENDING': 'WAITING_FOR_ENTRY',
                'TIME_EXIT': 'TIME_EXIT'
            };
            const mappedState = stateMap[outcome];
            if (mappedState) {
                if (outcome === 'PENDING') {
                    url += `&state=in.(WAITING_FOR_ENTRY,ENTRY_HIT)`;
                } else {
                    url += `&state=eq.${mappedState}`;
                }
            }
        }

        // Use count=exact to get total rows
        const res = await fetch(url, {
            headers: {
                "apikey": SB_KEY,
                "Authorization": `Bearer ${SB_KEY}`,
                "Prefer": "count=exact"
            }
        });

        if (!res.ok) throw new Error(`Supabase Error: ${res.status}`);

        const totalCount = parseInt(res.headers.get('content-range')?.split('/')?.[1] || 0);
        let signals = await res.json();

        tbody.innerHTML = "";

        if (!signals || signals.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="9" style="text-align:center; padding: 2rem; color: var(--text-secondary);">
                        <div style="font-weight: 600; font-size: 1.1rem; margin-bottom: 0.5rem; color: var(--text-primary);">No released signals in this period.</div>
                        <div style="font-size: 0.9rem;">Signals appear here only after being published on Telegram.</div>
                    </td>
                </tr>`;
            if (pageInfo) pageInfo.innerText = "Page 0 of 0";
            return;
        }

        signals.forEach(sig => {
            const dt = new Date(sig.generated_at);
            if (isNaN(dt.getTime())) return;

            const dStr = dt.toLocaleDateString('en-CA', { timeZone: 'UTC' });
            const tStr = dt.toLocaleTimeString('en-GB', { hour12: false, timeZone: 'UTC' }).slice(0, 5);

            const entry = sig.entry_price || sig.entry_low || 0;
            const sl = sig.sl || 0;
            const tp = sig.tp || 0;
            const direction = sig.direction || 'BUY';

            const confidence = sig.confidence || sig.ai_confidence || 0;
            const displayConfidence = confidence <= 1 ? Math.round(confidence * 100) : Math.round(confidence);

            let closedStr = "--:--";
            if (sig.closed_at) {
                const cdt = new Date(sig.closed_at);
                closedStr = cdt.toLocaleTimeString('en-GB', { hour12: false, timeZone: 'UTC' }).slice(0, 5);
            }

            const statusLabel = getStatusLabel(sig);
            const pips = getPipsInfo(sig);
            const resClass = (sig.result || '').toUpperCase() === 'PROFIT' ? 'up' : ((sig.result || '').toUpperCase() === 'LOSS' ? 'down' : 'neut');

            const row = document.createElement('tr');
            row.innerHTML = `
                <td data-label="Created" class="mono" style="font-size: 0.8rem">${dStr} ${tStr}</td>
                <td data-label="Side"><span class="pill ${direction.toLowerCase() === 'buy' ? 'up' : 'down'}">${direction}</span></td>
                <td data-label="AI Confidence" class="mono" style="font-weight:700; color:var(--quantix-accent)">${displayConfidence}%</td>
                <td data-label="Entry" class="mono">${parseFloat(entry).toFixed(5)}</td>
                <td data-label="TP" class="mono" style="color:var(--trade-up)">${parseFloat(tp).toFixed(5)}</td>
                <td data-label="SL" class="mono" style="color:var(--trade-down)">${parseFloat(sl).toFixed(5)}</td>
                <td data-label="Win/Loss" class="mono" style="font-weight:700; color:${pips.color}">${pips.label}</td>
                <td data-label="Closed" class="mono" style="font-size: 0.75rem">${closedStr}</td>
                <td data-label="Status"><span class="pill ${resClass}" style="min-width:80px; text-align:center">${statusLabel}</span></td>
            `;

            tbody.appendChild(row);
        });

        // Update Pagination UI
        const currentPage = Math.floor(historyOffset / PAGE_SIZE) + 1;
        const totalPages = Math.ceil(totalCount / PAGE_SIZE);

        if (pageInfo) pageInfo.innerText = `Page ${currentPage} of ${totalPages || 1}`;
        if (prevBtn) prevBtn.disabled = historyOffset === 0;
        if (nextBtn) nextBtn.disabled = historyOffset + PAGE_SIZE >= totalCount;

    } catch (e) {
        console.error("History fetch error:", e);
        tbody.innerHTML = `<tr><td colspan="9" style="text-align:center; color:var(--accent-red)">‚ö†Ô∏è Error loading history</td></tr>`;
    }
}

function getStatusLabel(s) {
    if (!s) return '--';
    const state = (s.state || '').toUpperCase();
    const result = (s.result || '').toUpperCase();

    if (result === 'PROFIT') return 'TP Hit';
    if (result === 'LOSS') return 'SL Hit';
    if (state === 'ENTRY_HIT') return 'Entry Hit';
    if (state === 'WAITING_FOR_ENTRY') return 'Waiting...';
    if (state === 'CANCELLED' || state === 'EXPIRED') return 'Expired';
    if (state === 'TIME_EXIT') return 'Time Exit';

    return state.replace(/_/g, ' ');
}

function getPipsInfo(s) {
    const entry = parseFloat(s.entry_price || s.entry_low || 0);
    const tp = parseFloat(s.tp || 0);
    const sl = parseFloat(s.sl || 0);
    const direction = (s.direction || 'BUY').toUpperCase();
    const result = (s.result || '').toUpperCase();

    let dist = 0;
    let label = '--';
    let color = 'var(--text-secondary)';

    if (result === 'PROFIT') {
        dist = Math.abs(entry - tp);
        label = `+${Math.round(dist * 10000 * 10) / 10} pips`;
        color = 'var(--trade-up)';
    } else if (result === 'LOSS') {
        dist = -Math.abs(entry - sl);
        label = `${Math.round(dist * 10000 * 10) / 10} pips`;
        color = 'var(--trade-down)';
    }

    return { label, color };
}

function mapState(state) {
    if (state === 'TP_HIT') return { label: 'TP Reached', class: 'tp' };
    if (state === 'SL_HIT') return { label: 'SL Reached', class: 'sl' };
    if (state === 'TIME_EXIT') return { label: 'Time-Based Exit', class: 'pending' };
    if (state === 'CANCELLED') return { label: 'Expired', class: 'expired' };
    return { label: 'Pending', class: 'pending' };
}

function updateHistoryClock() {
    const el = document.getElementById('dynamic-history-title');
    if (!el) return;
    const now = new Date();
    const utcStr = now.getUTCFullYear() + '-' +
        String(now.getUTCMonth() + 1).padStart(2, '0') + '-' +
        String(now.getUTCDate()).padStart(2, '0') + ' ' +
        String(now.getUTCHours()).padStart(2, '0') + ':' +
        String(now.getUTCMinutes()).padStart(2, '0') + ':' +
        String(now.getUTCSeconds()).padStart(2, '0');
    el.textContent = `Live Executions [ ${utcStr} UTC ]`;
}

// Initial Run
document.addEventListener('DOMContentLoaded', () => {
    updateHistoryClock();
    setInterval(updateHistoryClock, 1000);
    fetchLatestSignal();

    const fd = document.getElementById('filter-date');
    const loadMoreBtn = document.getElementById('load-more-btn');
    const outcomeTabs = document.querySelectorAll('.outcome-tab');

    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');

    if (fd) fd.addEventListener('change', () => loadHistory(false));

    // Initial load
    loadHistory(false);

    if (prevBtn) {
        prevBtn.addEventListener('click', () => {
            if (historyOffset >= PAGE_SIZE) {
                historyOffset -= PAGE_SIZE;
                loadHistory(true);
            }
        });
    }

    if (nextBtn) {
        nextBtn.addEventListener('click', () => {
            historyOffset += PAGE_SIZE;
            loadHistory(true);
        });
    }

    // Outcome Tabs logic
    outcomeTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            outcomeTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            loadHistory(false);
        });
    });

    setInterval(() => {
        if (activeTab === 'active') fetchLatestSignal();
    }, 60000);

    // Initialize live price feed
    initPriceFeed();
});

// === LIVE PRICE FEED ===
function initPriceFeed() {
    // EURUSDT trade stream from Binance
    const socket = new WebSocket('wss://stream.binance.com:9443/ws/eurusdt@trade');

    socket.onmessage = (event) => {
        const trade = JSON.parse(event.data);
        const price = parseFloat(trade.p);

        livePrice = price;
        pHistory.push(price);
        if (pHistory.length > 50) pHistory.shift();

        updatePriceUI();
    };

    socket.onerror = (error) => {
        console.warn("Pricing Feed Error:", error);
    };
}

function updatePriceUI() {
    const priceEl = document.getElementById('price-main');
    if (!priceEl || !livePrice) return;

    priceEl.textContent = livePrice.toFixed(5);
    priceEl.style.color = livePrice > prevPrice ? 'var(--trade-up)' : (livePrice < prevPrice ? 'var(--trade-down)' : 'var(--text-primary)');

    // Sparkline Update
    const linePath = document.getElementById('spark-line');
    const fillPath = document.getElementById('spark-fill');

    if (linePath && fillPath && pHistory.length > 2) {
        const min = Math.min(...pHistory);
        const max = Math.max(...pHistory);
        const range = (max - min) || 0.0001;
        const width = 100;
        const height = 60;

        const points = pHistory.map((v, i) => {
            const x = (i / (pHistory.length - 1)) * width;
            const y = height - ((v - min) / range) * (height - 10) - 5;
            return { x, y };
        });

        const d = `M ${points.map(p => `${p.x} ${p.y}`).join(' L ')}`;
        linePath.setAttribute('d', d);
        const fillD = `${d} L ${points[points.length - 1].x} ${height} L ${points[0].x} ${height} Z`;
        fillPath.setAttribute('d', fillD);
    }

    // Spread Randomizer (for aesthetic)
    const spreadEl = document.getElementById('price-spread');
    if (spreadEl && Math.random() < 0.2) {
        const spread = (0.2 + Math.random() * 0.2).toFixed(1);
        spreadEl.textContent = `${spread} pips`;
    }

    prevPrice = livePrice;
}
